syntax = "proto3";

package penumbra.custody.threshold.v1alpha1;

import "penumbra/core/transaction/v1alpha1/transaction.proto";
import "penumbra/crypto/decaf377_frost/v1alpha1/decaf377_frost.proto";

// A key one can use to verify signatures.
// 
// This key can also serve as a unique identifier for users.
message VerificationKey {
  bytes inner = 1;
}

// A signature proving that a message was created by the owner of a verification key.
message Signature {
  bytes inner = 1;
}

// The message the coordinator sends in round 1 of the signing protocol.
message CoordinatorRound1 {
  // The plan that the coordinator would like the followers to sign.
  core.transaction.v1alpha1.TransactionPlan plan = 1;
}

// The message the coordinator sends in round 2 of the signing protocol.
message CoordinatorRound2 {
  // The underlying signing packages being sent to the followers.
  repeated crypto.decaf377_frost.v1alpha1.SigningPackage signing_packages = 1;
}

// The first message the followers send back to the coordinator when signing. 
message FollowerRound1 {
  // The inner message that will be signed by the follower.
  message Inner {
    // One signing commitment pair for each signature requested by the plan, in order.
    repeated crypto.decaf377_frost.v1alpha1.SigningCommitments commitments = 1;
  }

  Inner inner = 1;
  // The verification key identifying the sender.
  VerificationKey pk = 2;
  // A signature over the proto-encoded bytes of inner.
  Signature sig = 3;
}

// The second message the followers send back to the coordinator when signing. 
message FollowerRound2 {
  // One share for each signature requested by the plan, in order.
  //
  // These can be unsigned, since any shenanigans will be detected when the signature
  // fails to verify.
  repeated crypto.decaf377_frost.v1alpha1.SignatureShare shares = 1;
}
